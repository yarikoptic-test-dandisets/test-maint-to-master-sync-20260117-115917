name: Sync maint ‚Üí master

on:
  push:
    branches: [maint]
  pull_request:
    branches: [master]
    types: [closed]
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'

permissions:
  contents: write
  pull-requests: write

jobs:
  sync:
    runs-on: ubuntu-latest
    steps:
      - name: Check out repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GH_PAT }}

      - name: Configure Git
        run: |
          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

      - name: Fetch latest branches
        run: |
          git fetch origin maint master

      - name: Check if sync is needed
        id: check_sync
        run: |
          # Check if master can be fast-forwarded to maint
          # This means: master is an ancestor of maint (no divergence)
          if git merge-base --is-ancestor origin/master origin/maint; then
            # Check if they're at the same commit
            if [ "$(git rev-parse origin/master)" = "$(git rev-parse origin/maint)" ]; then
              echo "sync_mode=none" >> "$GITHUB_OUTPUT"
              echo "‚úÖ Master and maint are identical - no sync needed"
            else
              echo "sync_mode=fast_forward" >> "$GITHUB_OUTPUT"
              echo "‚ö° Master can be fast-forwarded to maint (no divergence)"
            fi
          else
            # Master has diverged - need PR workflow
            MAINT_HASH=$(git rev-parse origin/maint)
            MERGE_BASE=$(git merge-base origin/maint origin/master)

            if [ "$MERGE_BASE" = "$MAINT_HASH" ]; then
              echo "sync_mode=none" >> "$GITHUB_OUTPUT"
              echo "‚ÑπÔ∏è  Maint has no new commits beyond master"
            else
              echo "sync_mode=pr" >> "$GITHUB_OUTPUT"
              echo "üîÄ Master has diverged - will use PR workflow"
            fi
          fi

      - name: Fast-forward master to maint
        if: steps.check_sync.outputs.sync_mode == 'fast_forward'
        run: |
          # Fast-forward master to maint (no PR needed)
          echo "Fast-forwarding master to maint..."

          # Create a temporary branch to test the update
          git checkout -b temp-ff-master origin/master
          git merge --ff-only origin/maint

          # Push to master
          git push origin temp-ff-master:master

          echo "‚úÖ Successfully fast-forwarded master to $(git rev-parse --short origin/maint)"
          echo "üìù Commits added to master:"
          git log --oneline origin/master..HEAD

      - name: Exit if no PR workflow needed
        if: steps.check_sync.outputs.sync_mode != 'pr'
        run: |
          if [ "${{ steps.check_sync.outputs.sync_mode }}" = "none" ]; then
            echo "Nothing to do - exiting successfully"
          else
            echo "Fast-forward completed - exiting successfully"
          fi

      - name: Check for existing PR
        if: steps.check_sync.outputs.sync_mode == 'pr'
        id: check_pr
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PR_DATA=$(gh pr list \
            --head maint-to-master \
            --base master \
            --state open \
            --json number,mergeable \
            --jq '.[0]')

          if [ -n "$PR_DATA" ] && [ "$PR_DATA" != "null" ]; then
            PR_NUMBER=$(echo "$PR_DATA" | jq -r '.number')
            echo "pr_exists=true" >> "$GITHUB_OUTPUT"
            echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
            echo "üìã Found existing PR #$PR_NUMBER"
          else
            echo "pr_exists=false" >> "$GITHUB_OUTPUT"
            echo "üìù No existing PR found"
          fi

      - name: Determine branch strategy
        if: steps.check_sync.outputs.sync_mode == 'pr'
        id: branch_strategy
        run: |
          if [ "${{ steps.check_pr.outputs.pr_exists }}" = "false" ]; then
            echo "strategy=create" >> "$GITHUB_OUTPUT"
          else
            git fetch origin maint-to-master 2>/dev/null || {
              echo "strategy=create" >> "$GITHUB_OUTPUT"
              exit 0
            }

            MAINT_HASH=$(git rev-parse origin/maint)
            BRANCH_HASH=$(git rev-parse origin/maint-to-master)

            if [ "$BRANCH_HASH" = "$MAINT_HASH" ]; then
              echo "strategy=force_reset" >> "$GITHUB_OUTPUT"
            else
              echo "strategy=merge_forward" >> "$GITHUB_OUTPUT"
            fi
          fi

      - name: Create or update maint-to-master branch
        if: steps.check_sync.outputs.sync_mode == 'pr'
        id: update_branch
        run: |
          STRATEGY="${{ steps.branch_strategy.outputs.strategy }}"

          if [ "$STRATEGY" = "create" ] || [ "$STRATEGY" = "force_reset" ]; then
            # Create branch from origin/maint
            git checkout -B maint-to-master origin/maint

            # Try to merge origin/master into it
            if git merge origin/master --no-edit -m "Merge master into maint-to-master"; then
              echo "merge_status=clean" >> "$GITHUB_OUTPUT"
              echo "‚úÖ Clean merge"
            else
              echo "merge_status=conflict" >> "$GITHUB_OUTPUT"
              echo "‚ö†Ô∏è  Merge conflicts"
              git merge --abort
              # Reset to maint without the merge
              git checkout -B maint-to-master origin/maint
            fi

            git push -f origin maint-to-master

          elif [ "$STRATEGY" = "merge_forward" ]; then
            # Check out existing branch
            git checkout -B maint-to-master origin/maint-to-master

            # Merge new maint commits
            if git merge origin/maint --no-edit -m "Merge new maint commits"; then
              echo "merge_status=clean" >> "$GITHUB_OUTPUT"
              git push origin maint-to-master
            else
              echo "merge_status=conflict" >> "$GITHUB_OUTPUT"
              git push origin maint-to-master || true
            fi
          fi

      - name: Create PR
        if: steps.check_sync.outputs.sync_mode == 'pr' && steps.check_pr.outputs.pr_exists == 'false'
        id: create_pr
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          MERGE_STATUS="${{ steps.update_branch.outputs.merge_status }}"

          if [ "$MERGE_STATUS" = "conflict" ]; then
            STATUS_NOTE="‚ö†Ô∏è **MERGE CONFLICTS** - Manual resolution required"
            AUTO_MERGE_ENABLE="false"
          else
            STATUS_NOTE="‚úÖ Clean merge - will auto-merge when CI passes"
            AUTO_MERGE_ENABLE="true"
          fi

          COMMIT_COUNT=$(git log --oneline origin/master..maint-to-master | wc -l)

          PR_URL=$(gh pr create \
            --base master \
            --head maint-to-master \
            --title "Sync maint ‚Üí master ($COMMIT_COUNT commits)" \
            --body "$(cat <<EOF
          ## üîÑ Automated Maintenance Sync

          **Status:** $STATUS_NOTE

          **Commits from maint:** $COMMIT_COUNT

          ### Changes
          \`\`\`
          $(git log --oneline --graph origin/master..maint-to-master | head -10)
          \`\`\`

          ü§ñ Auto-generated by sync-maint-to-master workflow
          EOF
          )")

          # Extract PR number from URL (format: https://github.com/owner/repo/pull/123)
          PR_NUMBER=$(echo "$PR_URL" | grep -oP '/pull/\K\d+$')

          echo "pr_number=$PR_NUMBER" >> "$GITHUB_OUTPUT"
          echo "auto_merge=$AUTO_MERGE_ENABLE" >> "$GITHUB_OUTPUT"

      - name: Update existing PR
        if: steps.check_sync.outputs.sync_mode == 'pr' && steps.check_pr.outputs.pr_exists == 'true'
        id: update_pr
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PR_NUMBER="${{ steps.check_pr.outputs.pr_number }}"
          MERGE_STATUS="${{ steps.update_branch.outputs.merge_status }}"

          if [ "$MERGE_STATUS" = "conflict" ]; then
            MESSAGE="üîÑ Updated - ‚ö†Ô∏è Conflicts detected"
            AUTO_MERGE_ENABLE="false"
          else
            MESSAGE="üîÑ Updated - ‚úÖ Clean merge"
            AUTO_MERGE_ENABLE="true"
          fi

          gh pr comment "$PR_NUMBER" --body "$MESSAGE"
          echo "auto_merge=$AUTO_MERGE_ENABLE" >> "$GITHUB_OUTPUT"

      - name: Enable auto-merge
        if: steps.check_sync.outputs.sync_mode == 'pr' && (steps.create_pr.outputs.auto_merge == 'true' || steps.update_pr.outputs.auto_merge == 'true')
        env:
          GH_TOKEN: ${{ secrets.GH_PAT }}
        run: |
          PR_NUMBER="${{ steps.create_pr.outputs.pr_number || steps.check_pr.outputs.pr_number }}"
          gh pr merge "$PR_NUMBER" --auto --merge || echo "Auto-merge may already be enabled"
